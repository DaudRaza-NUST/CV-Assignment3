#%%

import cv2
import numpy as np
import matplotlib.pyplot as plt
img = cv2.imread('image1.png')
rows, cols = img.shape[:2]
print(rows, cols)

# The image is generated by a kernel rolling over the entirety of the image. 

# A odd numbered kernel is used in order to prevent bias, and for pixel skipping

# The vignetter filter is generally used to focuse viewer attention on certain parts
# of the image without hiding other parts. 

# generating vignetter mask using kernels

kernel_x = cv2.getGaussianKernel(cols, 150)
kernel_y = cv2.getGaussianKernel(rows, 150)
kernel = kernel_y * kernel_x.T
mask = 255*kernel/np.linalg.norm(kernel)
output = np.copy(img)

#applying the mask to each channel in the output image

for i in range(3):
    output[:,:,i] = mask*output[:,:,i]

#removing the vignette filter from the image

remove = np.copy(output)
for i in range(3):
    remove[:,:,i] = remove[:,:,i]/mask

#plotting the images

f, axarr = plt.subplots(2,2)
axarr[0,0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
axarr[0,1].imshow(cv2.cvtColor(output, cv2.COLOR_BGR2RGB))
axarr[1,0].imshow(cv2.cvtColor(remove, cv2.COLOR_BGR2RGB))
plt.show()

#%%
#removing the vignette filter from a new image
import cv2
import numpy as np
import matplotlib.pyplot as plt
img = cv2.imread('image2.jpeg')
rows, cols = img.shape[:2]
print(rows, cols)

kernel_x = cv2.getGaussianKernel(cols, 200)
kernel_y = cv2.getGaussianKernel(rows, 200)
kernel = kernel_y * kernel_x.T
mask = 255*kernel/np.linalg.norm(kernel)
output = np.copy(img)

for i in range(3):
    output[:,:,i] = output[:,:,i]/mask

#increase the brightness of the image

output = cv2.convertScaleAbs(output, alpha=1.2, beta=25)

f, axarr = plt.subplots(1,2)
axarr[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
axarr[1].imshow(cv2.cvtColor(output, cv2.COLOR_BGR2RGB))
plt.show()
